SDRAM
=====

_WIP_

Let us try to talk to the SDRAM chip of the ULX3S and OrangeCrab ! For now, this page contains
some unstructured notes, I'm currently gathering information and trying some designs. Progress
will be reported here.


- *Goal 1*: A graphic board with a 640x480 (then full HD) 24 bits RGB framebuffer
that displays a simple animated pattern generated by a
simple writer circuit (and then a FemtoRV32). _WIP_ project is [here](https://github.com/BrunoLevy/learn-fpga/tree/master/Basic/ULX3S_SDRAM_hdmi).

- *Goal 2*: Integrate in FemtoSOC, with full access from FemtoRV32.

Misc notes
----------
- Address: Bank, Row, Column
- Commands: open row (activate), read/write, close row (precharge _misleading: pre-charge means closing the row_)
- Refresh: either auto-refresh, or access rows
- FPGA4Fun example: ideal for graphic board (dual ported, read agent
refreshes)
- DDR RAMS
- ULX3S data sheet: 32MB SDRAM, 166MHz, 16-bit [Micron MT48LC32M16](https://www.digchip.com/datasheets/parts/datasheet/297/MT48LC32M16.php)
   - But on my own ULX3S: [ALLIANCE AS4C32M16SB-7TCN](https://www.alliancememory.com/wp-content/uploads/pdf/dram/512M%20SDRAM_%20B%20die_AS4C32M16SB-7TCN-7TIN-6TIN_Rev%201.0%20June%202016.pdf)
   - ... and there are other variants (see comments in sylefeb's Silice memory controller)

Pins
----
- clk      : 143MHz clock (7TCN series)
- cke      : clock enable (wire to 1)
- csn      : chip select (high: everything inhibited)
- command: [wen, rasn, casn]
   - wen      : write enable (read/write bit)             
   - rasn     : row address strobe (but not a strobe)     
   - casn     : column address strobe (but not a strobe)  
- a[12:0]  : address (+ 1 line to select operations burst/auto close and close in bank, close in all banks)
- ba[1:0]  : bank
- dqm[1:0] : data mask (high: suppress data I/O). One line per 8 bits.
- d[15:0]  : bidirectional data bus

Commands
--------
- nop
- load mode
- open row (activate)
- read
- write
- close row (precharge)
- refresh

State machine
-------------
[FPGA4fun](https://www.fpga4fun.com/SDRAM.html)
- Idle
- open row (activate) on transition
- Read/Write
- Close row (precharge)
- Nop


There are 'small caps' in the FPGA4fun design, read comments carefully:
 - Need to initialize CAS (Column Address Strobe) latency=2 and any valid burt mode
 - Read agent is active enough to refresh the RAM
   If these conditions are not met, we may need also:
    - a timer and 'refresh state' if reader is not active enough
    - additional 'nop' states after opening and closing a row if CAS is more than 2

Questions
---------
   - Q1: How to initialize MODE register properly ?_[OK, P. 14 of datasheet]_
   - Q2: What are the different modes ? _[OK]_
   - Q3: How to synchronize data read and video signal generation ?
   - Q4: Which one is the 'special' address line that selects burst mode ? _[OK, it's A10]_
   - Q5: Timings ? Relation between CAS and freq ? P 15. of datasheet + table P 21. _[OK]_
   - Q6: What is auto-precharge, auto-refresh, self-refresh ? _[OK]_
   - Q7: At that freq, we probably need specialized FPGA blocs for latched IO pins.
   - Q8: How to implement init. sequence ? Wired ? Micro-programmed in BRAM ? CPU-controlled ? _[OK: small counter]_
   - Q9: What is the _largest common subset_ of all the chips used on the ULX3S ? _[OK]_

Read chip datasheet (on my board: ALLIANCE AS4C32M16SB-7TCN)
------------------------------------------------------------
- Fast clock rate: 166/143 MHz
- 512 Mbits (64 MBytes): 8M words x 16 bits x 4 banks
- Modes
   - CAS Latency: 2 or 3
   - Burst length: 1,2,4,8 or full page
   - Burst type: sequential or interleaved
   - Burst stop function
- Auto refresh / self refresh
- 8192 refresh cycles / 64 ms
- Bank Activate: row address = A[12:0]
- Read/write: column address = A[9:0], auto-precharge = A[10]
- Mode register set: op code = A[..:..]
- Page 7: list of commands (19 commands !)

Mode Register Bitmap:

|BA1|BA0|A12|A11|A10|A09|A08|A07|A06|A05|A04|A03|A02|A01|A00|  
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| X | 0 | X | X | X |WBL|Tst|Tst|CAS|CAS|CAS|BT |Bst|Bst|Bst|

| Field name          | Field description                                  |
|---------------------|----------------------------------------------------|
|WBL (Write Burst Len)| 0: Burst 1: single bit                             |
|Test Mode            | 0 0 (else configs for vendor only)                 |
|CAS latency          | 010 (2 clocks) or 011 (3 clocks)                   |
|BT (Burst Type)      | 0: sequential 1: interleave                        |
|Burst len            | 000:1 001:2 010:4 011:8 111:full page (sequential) |

Answers to questions
--------------------

*Q1,Q2,Q8: MODE register and initialization sequence ?*

|BA1|BA0|A12|A11|A10|A09|A08|A07|A06|A05|A04|A03|A02|A01|A00|  
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| X | 0 | X | X | X | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
 
- WBL: *0: Burst* 1: single bit _I do not know what this means_
- CAS latency: *010: 2 clocks* _required by FPGA4Fun design_
- BT: *0: sequential* 1: interleave _I do not know wht this means_
- Burst len: *001: 2* _set it to 2 for 32 bits_

Initialization sequence (datasheet page 14)

- CKE goes high, DQM goes low, DQ goes Z
- wait 1 cycles
- precharge all
- wait tRP
- Mode Register Set
- wait tMRD (1 cycle)
- first command can be sent

Note: Initialization sequence described [here](https://www.hackster.io/salvador-canas/a-practical-introduction-to-sdr-sdram-memories-using-an-fpga-8f5949)
is more complicated, maybe I missed something. Taking a look at initialization sequence in Silice, Lawrie's and stffrdhrn's controllers, it seems
that the initialization sequence above can do the job (but I'm unsure it will work with all SDRAM chips). I think I'll use a simple cycles counter that
runs during the initialization sequence (and that inhibited by the global signal reset so that the chip as sufficient time at power up).

*Q3: synchronize data read and video signal generation ?*

*Q6: auto-precharge, self-refresh, auto-refresh ?
The MICRON tech sheet is easier to read. Let us see what it says:
- auto-precharge: row is precharged (closed) after burst read or burst write
- auto-refresh: addr generated by internal refresh controler. Just
  need to ping it regularly one by one, or burst-refresh less often everything.
- self-refresh: retain data when the rest of the system is powered down.

*Q9: what is the _largest common subset_ for all the SDRAM chips used on the ULX3S ?*

| Brand   | Reference   | Capacity | Width   | Banks | Rows | Columns | 
|---------|-------------|----------|---------|-------|------|----------
|Micron   | MT48LC32M16 |  64 MB   | 16 bits |  4    | 8192 | 1024    |                    
|ALLIANCE | AS4C32M16SB |  64 MB   | 16 bits |  4    | 8192 | 1024    | 
|ALLIANCE | IS42S16160G |  32 MB   | 16 bits |  4    | 8192 | 512     |                 
|ALLIANCE | AS4C16M16SA |  32 MB   | 16 bits |  4    | 8192 | 512     |

*Q5: Timings and relation between CAS and freq ?*

Timing for AS4C32M16SB-7TCN (table 16 p. 21 in datasheet):
7-TCN means tCK3=7ns = 143MHz, but with CL=2, drops to 10ns (100MHz).

The most important parameters:
tRCD (RAS to CAS), CL (CAS latency) and tRP (Precharge to Refresh Row).


 | Time  | Value | Explanation                                  |
 |-------|-------|----------------------------------------------|
 | tCK   | 10ns  | clock, with CAS Latency=2                    |
 | tRC   | 63ns  | row cycle time                               |
 | tRCD  | 21ns  | RAS to CAS, same bank                        |
 | tRP   | 21ns  | precharge to refresh/row activate, same bank |
 | tRRD  | 14ns  | row activate to row activate, different bank |
 | tMRD  | 14ns  | mode register set                            |
 | tRAS  | 42ns  | row activate to precharge. max=120K          |
 | tWR   | 14ns  | write recovery time                          |
 | tREFI | 7.8us | average refresh interval time                |
 | tDAL  | 25ns  | tDAL = tWR + tRP                             |

Q: this timings look like what for other chips ? Let us see for
the Micron MT48LC32M16-75 (table p. 33 of the datasheet). Good news,
the symbols for the timings seem to be the same even with different
SDRAM brands:

 | Time  | Value | Explanation                                    |
 |-------|-------|------------------------------------------------|
 | tCK   | 7.5ns | clock, CAS Latency=2 or 3,speed grade 7E or 75 |
 | tRC   | 66ns  | row cycle time                                 |
 | tRCD  | 20ns  | RAS to CAS, same bank                          |
 | tRP   | 20ns  | precharge to refresh/row activate, same bank   |
 | tRRD  | 15ns  | row activate to row activate, different bank   |
 | tMRD  | 2clk  | mode register set                              |
 | tRAS  | 44ns  | row activate to precharge. max=120K            |
 | tWR   | 2clk  | write recovery time                            |
 | tREFI | 7.81us| average refresh interval time                  |
 | tDAL  | 35ns  | tDAL = tWR + tRP                               |

Refresh: 8192 AUTO REFRESH cycles in a burst (spaced by tRC) every
64ms (tREF) or 1 AUTO REFRESH cycle every 7.81 us.

*Q7: At that freq, we will probably need specialized IO blocks, which ones ?*

Very well explained in this example for [Alchetry](https://alchitry.com/blogs/tutorials/sdram-verilog). There are three things:
 - SDRAM clock needs to be inverted
 - SDRAM clock needs to be delayed
 - Input-Output registers need to be embedded in the IO buffers to ensure that all signals are received / send at the same time, for:
    - cle (clock enable)
    - dqm (2-bits data mask)
    - cmd (3-bits command)
    - ba  (2-bits bank address)
    - a   (address)
    - q   (data out)
    - qi  (data in)

It needs to be adapted:
 - we have 16 bits SDRAM (instead of 8 bits in the example), plus all the timings are probably different
 - ECP5 specialized primitives, refer to
   [All Lattice blocks](http://www.latticesemi.com/-/media/LatticeSemi/Documents/UserManuals/EI2/FPGA_Libraries_Reference_Guide_310.ashx?document_id=52213)
 - [Yosys ECP5](https://github.com/YosysHQ/nextpnr/blob/master/ecp5/docs/primitives.md) 
 - [TRELLIS_IO](https://github.com/YosysHQ/yosys/blob/master/techlibs/ecp5/cells_sim.v#L261)

We will need:
  - latches (in) and flip-flops (out) attached to the IO-pins (how to do that with ECP5, `BB`,`IB`,`OB` ?).
     How can we have a latch there ? On Ice-40 it is `SB_GB_IO`. On ECP5, seems to be `IFS1P3BX`,`OFS1P3BX` that
     are packed into the IO by nextpnr, see discussion [here](https://github.com/YosysHQ/nextpnr/issues/399).
  - send clock to SDRAM at each falling edge instead of rising edge (using `ODDRX1F` (probably) with constant bits 0 and 1)
  - clock delay (how to do that with ECP5, `DELAYF`,`DELAYG` ?)
  - `IFS1P3BX`,`OFS1P3BX` _(what's that ? I need to RTFM...)_ They are PICs (Programmable IO Cells).
    Some information [here](file:///tmp/mozilla_blevy0/FPGA-DS-02012-2-1-ECP5-ECP5G-Family-Data-Sheet.pdf)
    and [here](file:///tmp/mozilla_blevy0/FPGALibrariesReferenceGuide35.pdf)
  - `BB` used [here](https://github.com/sylefeb/Silice/blob/master/projects/common/inout16_ff_ulx3s.v)

OK, the way to do it is a `IFS1P3BX` combined with a `BB` in a single PIC (programmable IO Cell). Normally
nextpnr-ecp5 supports that (according to latest posts [here](https://github.com/YosysHQ/nextpnr/issues/399)).


A framebuffer in SDRAM ? HDMI 640x480 timings
=============================================

_Less sure that it is the way to go to test the design, seems to be easier to do a general controller with valid/busy/ready protocol
 and map it in the address space of FemtoRV32, will see..._

Refresh
-------
  - 800x525x60Hz - pixel clock = 25MHz
  - each pixel row has a 140 pixels hblank period = 5.6us _we can 'distributed-refresh' here_
  - vblank period = 1.44ms _we can 'burst-refresh' here_

Reading the framebuffer
-----------------------
  Maybe we could keep in BRAM one row of pixels, and burst-read it (with burst len = full page). The question is: does this fit in
one single row of SDRAM ? The answer is no (depending on the chip, we got 1kB or 2kBs per row). But maybe this is not a problem:
the SDRAM goes at 100MHz and the screen's pixel clock at 25MHz, the best thing to do is probably to have two line buffers, and
displaying the current one while reading the next one, so that we can read 4 bytes per pixel. And in fact, if we do that, we probably
even do not need to do AUTO REFRESH cycles. 
  
Writing to the framebuffer
--------------------------
  Now when can I write to the framebuffer ? Seems that if I read it as planned, the only possible times for writing will be during the
last 1/4 end of the scanline plus the hblank time, and during the vblank time. I'd probably like to have something more fine-grained.
Or maybe the best option is to have two SDRAM chips, with two pages of graphics, one in read-only mode, and the other-one in write-only
mode (this one will do refresh). But can I do that in the same chip ? Does not seem to be very likely. 

Wait a minute, are there some resources on the web I can get inspiration from ? Yes, there is
[this class](https://courses.cs.washington.edu/courses/cse467/15wi/docs/prj2.pdf), it even talks about the ZBuffer, great !
Let us see what we learn from there... They use a pre-made SDRAM controller
[here](https://courses.cs.washington.edu/courses/cse467/15wi/docs/sdramsample.tar.gz). Seems to be very sophisticated (has FIFOs),
well, I'd prefer a simpler one...

There is also this [StackExchange answer](https://electronics.stackexchange.com/questions/269227/generating-frame-buffer-in-fpga),
my ideas seem to correspond more or less with it (no miracle, we cannot read and write in the same chip simultaneously).

There are also interesting ideas
[here](https://www.fpgakey.com/wiki/details/385), it gives some
information on how the Northbridge works. Seems that certain chips can
open several rows simultaneously (but probably not the chip we have
here).

Could we have framebuffer and general RAM in the same SDRAM chip ?
-------------------------------------------------------------------
  Probably yes, but this means:
  
 - managing refresh cycles on our own. FrameBuffer is refreshed by continuous reading, and the rest by refresh cycles schedules with
   other I/O operations.
 - I/O operations occur during HBlank/VBlank. 


References
==========
- [FPGA4fun](https://www.fpga4fun.com/SDRAM.html)
- [Lawrie](https://github.com/lawrie/ulx3s_68k/blob/master/src/sdram.v)
- [stffrdhrn](https://github.com/stffrdhrn/sdram-controller)
- [Hackaday](https://hackaday.com/2013/10/11/sdram-controller-for-low-end-fpgas/)
- [Wikipedia](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory)
- [Hackster](https://www.hackster.io/salvador-canas/a-practical-introduction-to-sdr-sdram-memories-using-an-fpga-8f5949)
- [Chip datasheet (ALLIANCE AS4C32M16SB-7TCN)](https://www.alliancememory.com/wp-content/uploads/pdf/dram/512M%20SDRAM_%20B%20die_AS4C32M16SB-7TCN-7TIN-6TIN_Rev%201.0%20June%202016.pdf)
- [Silice](https://github.com/sylefeb/Silice/blob/master/projects/common/sdram_controller_autoprecharge_r16_w16.ice)
- [A simple one](http://ladybug.xs4all.nl/arlet/fpga/source/sdram.v)
- [Tutorial for Alchitry (seems to be good)](https://alchitry.com/blogs/tutorials/sdram-verilog)
- [A twitter thread about the history of SDRAM](https://twitter.com/TubeTimeUS/status/1365774008180908034)
- [Arlet's SDRAM controller](http://ladybug.xs4all.nl/arlet/fpga/source/sdram.v)
